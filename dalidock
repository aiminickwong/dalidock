#!/usr/bin/python3 -u
# -*- coding: utf-8 -*-

import docker
import json
import os
import sys
import signal

# docker default values
DOCKER_SOCKET = os.getenv('DOCKER_SOCKET', 'unix://var/run/docker.sock')
DOCKER_IP     = os.getenv('DOCKER_IP', '172.17.0.1')

# DNS default values
DNS_DOMAIN   = os.getenv('DNS_DOMAIN',   'local')
DNS_WILDCARD = os.getenv('DNS_WILDCARD', 'false')

# dnsmasq default values
DNSMASQ_WILDCARDS_FILE = os.getenv('DNSMASQ_WILDCARDS_FILE', '/run/dnsmasq/conf/docker')
DNSMASQ_HOSTS_FILE     = os.getenv('DNSMASQ_HOSTS_FILE',     '/run/dnsmasq/hosts/docker')

def get_process_info():
    return "%s[%d]" % (os.path.basename(sys.argv[0]), os.getpid())

def log(msg, level="INFO", hostname=False):
    if hostname:
        print("%s: %-7s %-28s %s" % (get_process_info(), "[%s]" % level, "[%s]" % hostname, msg))
    else:
        print("%s: %-7s %s" % (get_process_info(), "[%s]" % level, msg))

def error(msg, hostname=False):
    log(msg, level="ERROR", hostname=hostname)

def fatal(msg, hostname=False):
    log(msg, "FATAL", hostname=hostname)
    sys.exit(1)

def sighandler(sig, frame):
    print ("")
    sys.exit(0)

class DockerClient(object):
    def __init__(self, url='unix://var/run/docker.sock'):
        self.url  = url
        self.conn = docker.Client(base_url=self.url)

        self.showInformations()

    def showInformations(self):
        docker_infos   = self.conn.info()
        docker_version = self.conn.version()

        log("Kernel:           %s"   % (docker_infos['KernelVersion']))
        log("Operating System: %s"   % (docker_infos['OperatingSystem']))
        log("Docker Version:   %s"   % (docker_version['Version']))
        log("API Version:      %s\n" % (docker_version['ApiVersion']))

    def getContainerData(self, containerid):
        try:
            return self.conn.inspect_container(containerid)
        except docker.errors.NotFound:
            error("Container '%s' does not exists" % (containerid))
            return False
        except docker.errors.APIError as e:
            error("API error while getting information: %s" % (str(e)))
            return False

    def getId(self, data):
        # return container id
        return data['Id']

    def getName(self, data):
        # return container name
        return data['Name'].replace('/', '')

    def getHostname(self, data):
        # return container hostname
        return data['Config']['Hostname']

    def getIPAddress(self, data):
        # return container main IP address

        for net in data['NetworkSettings']['Networks']:
            if net == 'host':
                return DOCKER_IP
            else:
                return data['NetworkSettings']['Networks'][net]['IPAddress']

    def getNetworkName(self, data):
        # return first network name

        for net in data['NetworkSettings']['Networks']:
            return net

        return False

    def getLabels(self, data):
        # return container's labels
        return data['Config']['Labels']

    def getLabel(self, data, name, default=False):
        # return container's label 'name'

        labels = self.getLabels(data)

        if name not in labels:
            return default

        return labels[name]

class DockerEventsHandler(object):
    def __init__(self):
        self.docker = DockerClient(DOCKER_SOCKET)
        self.dns    = DnsEntries()
        self.loop   = True

    def serve(self):
        log("Starting docker events handler")

        # get all running containers, then fix/update their network configuration if needed
        self.loadAllContainers()

        # listenning events
        events_generator = self.docker.conn.events(decode=False)

        while self.loop:
            evts = next(events_generator)

            for evt in evts.decode('utf8').split('\n'):
                if not evt:
                    # We've got an empty string
                    continue

                self.processEvt(evt)

    def loadAllContainers(self):
        for container in self.docker.conn.containers():
            self.handleContainer(container['Id'], 'start')

    def processEvt(self, evt):
        evt = json.loads(evt)

        if 'Type' not in evt.keys() or evt['Type'] != 'container':
            # this event is useless because not related to container state, skipping (fix for docker 1.10+)
            return

        containerid = evt['id']
        status      = evt['status']

        if status not in ['start', 'die']:
            # These events can be dropped as we are not handling them
            return

        self.handleContainer(containerid, status)

    def handleContainer(self, containerid, status):
        data = self.docker.getContainerData(containerid)

        if not data:
            error("Fail to fetch description of container '%s'" % (containerid))
            return

        cid              = self.docker.getId(data)
        name             = self.docker.getName(data)
        hostname         = self.docker.getHostname(data)
        ipaddress        = self.docker.getIPAddress(data)
        network          = self.docker.getNetworkName(data)
        dns_domain       = self.docker.getLabel(data, 'dns.domain',   DNS_DOMAIN)
        dns_use_wildcard = self.docker.getLabel(data, 'dns.wildcard', DNS_WILDCARD).lower()
        dns_aliases      = self.docker.getLabel(data, 'dns.aliases',  '')
        if dns_use_wildcard in [ '1', 'true', 'yes' ]:
            dns_use_wildcard=True
        else:
            dns_use_wildcard=False

        log("name=%-10s hostname=%-10s ip=%-15s net=%-10s domain=%-10s use_wildcard=%s" % (name, hostname, ipaddress, network, dns_domain, dns_use_wildcard))

        if   status == 'start':
            self.dns.add(cid, hostname, ipaddress, network, dns_domain, name, dns_aliases, dns_use_wildcard)
        elif status == 'die':
            self.dns.remove(cid)

        self.dns.update()

class DnsEntries(object):
    def __init__(self):
        self.entries          = dict()
        self.cached_etc_hosts = ""
        self.cached_wildcards = ""

    def add(self, cid, hostname, ipaddress, network, domain, name, aliases, use_wildcard):
        entry = {
            'hostname':     hostname,
            'ipaddress':    ipaddress,
            'network':      network,
            'domain':       domain,
            'name':         name,
            'aliases':      [name],
            'use_wildcard': use_wildcard,
        }

        for alias in aliases.split(','):
            if not alias:
                # empty string
                continue

            entry['aliases'].append(alias)

        self.entries[cid] = entry

    def remove(self, cid):
        if cid in self.entries:
            del self.entries[cid]

    def show(self):
        for entry in self.entries:
            print (self.entries[entry])

    def generate(self):
        etc_hosts = ""
        wildcards = ""

        for entry in self.entries:
            data       = self.entries[entry]
            etc_hosts += "%-15s" % (data['ipaddress'])
            hosts      = list()

            # put FQDN on top to make dnsmasq properly handle reverse DNS
            hosts.append("%s.%s" % (data['hostname'], data['domain']))

            # loop on host names
            for host in [
                    "%s"    % (data['hostname']),
                    "%s.%s" % (data['name'], data['domain']),
                    "%s"    % (data['name']),
                    ]:
                if host not in hosts:
                    hosts.append(host)

            # loop on aliases
            for alias in data['aliases']:
                # strip starting dots or wildcards
                for prefix in [ '*.', '.', '*' ]:
                    alias = alias[alias.startswith(prefix) and len(prefix):]

                # avoid duplication of domain name, like 'alias.domain.domain'
                if alias.endswith(data['domain']):
                    alias = alias[:-len(data['domain'])-1]

                if alias not in hosts:
                    hosts.append("%s"    % (alias))
                    hosts.append("%s.%s" % (alias, data['domain']))

            # append generated line
            for host in hosts:
                etc_hosts += " %s" % (host)

            # add wildcard configuration if needed
            if data['use_wildcard']:
                for host in hosts:
                    wildcards += "address=/%s/%s\n" % (host, data['ipaddress'])

            # end of host defintion
            etc_hosts += "\n"

        return etc_hosts, wildcards

    def update(self):
        new_etc_hosts, new_wildcards = self.generate()

        if self.cached_etc_hosts != new_etc_hosts:
            log("Hosts entries have changed, write/reload configuration")

            self.cached_etc_hosts = new_etc_hosts

            with open(DNSMASQ_HOSTS_FILE, 'w') as fd:
                fd.write(self.cached_etc_hosts)

            self.reload()

        if self.cached_wildcards != new_wildcards:
            log("Wildcards entries have changed, write/reload configuration")

            self.cached_wildcards = new_wildcards

            with open(DNSMASQ_WILDCARDS_FILE, 'w') as fd:
                fd.write(self.cached_wildcards)

            self.restart()

    def reload(self):
        os.system("sv hup dnsmasq")

    def restart(self):
        os.system("sv restart dnsmasq")

signal.signal(signal.SIGINT,  sighandler)
signal.signal(signal.SIGTERM, sighandler)

def main():
    evt_handler = DockerEventsHandler()
    evt_handler.serve()

if __name__ == '__main__':
    main()
